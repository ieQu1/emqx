%%--------------------------------------------------------------------
%% Copyright (c) 2023 EMQ Technologies Co., Ltd. All Rights Reserved.
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%%     http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.
%%--------------------------------------------------------------------
-module(emqx_ds).

-include_lib("stdlib/include/ms_transform.hrl").
-include_lib("snabbkaffe/include/snabbkaffe.hrl").

%% API:
-export([ensure_shard/2]).
%%   Messages:
-export([message_store/2, message_store/1, message_stats/0]).
%%   Iterator:
-export([get_streams/3, open_iterator/1, next/2]).

%% internal exports:
-export([]).

-export_type([
              stream/0,
    keyspace/0,
    message_id/0,
    message_stats/0,
    message_store_opts/0,
    replay/0,
    replay_id/0,
              %iterator_id/0,
    iterator/0,
    topic/0,
    topic_filter/0,
    time/0
]).

%%================================================================================
%% Type declarations
%%================================================================================

%% This record enapsulates the stream entity from the storage level.
%%
%% TODO: currently the stream is hardwired to only support the
%% internal rocksdb storage. In t he future we want to add another
%% implementations for emqx_ds, so this type has to take this into
%% account.
-record(stream,
        { shard :: emqx_ds:shard()
        ,  :: emqx_ds_storage_layer:stream()
        }).

-opaque stream() :: #stream{}.

-type iterator() :: term().

%-type iterator_id() :: binary().

-type message_store_opts() :: #{}.

-type message_stats() :: #{}.

-type message_id() :: binary().

%% Parsed topic.
-type topic() :: list(binary()).

%% Parsed topic filter.
-type topic_filter() :: list(binary() | '+' | '#' | '').

-type keyspace() :: atom().
-type shard_id() :: binary().
-type shard() :: {keyspace(), shard_id()}.

%% Timestamp
%% Earliest possible timestamp is 0.
%% TODO granularity?  Currently, we should always use micro second, as that's the unit we
%% use in emqx_guid.  Otherwise, the iterators won't match the message timestamps.
-type time() :: non_neg_integer().

-type replay_id() :: binary().

-type replay() :: {
    _TopicFilter :: topic_filter(),
    _StartTime :: time()
}.

%%================================================================================
%% API funcions
%%================================================================================

%% @doc Get a list of streams needed for replaying a topic filter.
%%
%% Motivation: under the hood, EMQX may store different topics at
%% different locations or even in different databases. A wildcard
%% topic filter may require pulling data from any number of locations.
%%
%% Stream is an abstraction exposed by `emqx_ds' that reflects the
%% notion that different topics can be stored differently, but hides
%% the implementation details.
%%
%% Rules:
%%
%% 1. New streams matching the topic filter can appear without notice,
%% so the replayer must periodically call this function to get the
%% updated list of streams.
%%
%% 2. Streams may depend on one another. Therefore, care should be
%% taken while replaying them in parallel to avoid out-of-order
%% replay. This function returns stream together with its
%% "coordinates": `{X, T, Stream}'. If X coordinate of two streams is
%% different, then they can be replayed in parallel.  If it's the
%% same, then the stream with smaller T coordinate should be replayed
%% first.
-spec get_streams(keyspace(), topic_filter(), time()) -> [{integer(), integer(), stream()}].
get_streams(Keyspace, TopicFilter, StartTime) ->
    ShardIds = emqx_ds_replication_layer:get_all_shards(Keyspace),
    lists:flatmap(
      fun(Shard) ->
              Node = emqx_ds_replication_layer:shard_to_node(Shard),
              try
                  Streams = emqx_persistent_session_ds_proto_v1:get_streams(Node, Keyspace, Shard, TopicFilter, StartTime),
                  [#stream{ shard = {Keyspace, ShardId}
                          , stream = Stream
                          } || Stream <- Streams]
              catch
                  error:{erpc, _} ->
                      %% The caller has to periodically refresh the
                      %% list of streams anyway, so it's ok to ignore
                      %% transient errors.
                      []
              end
      end,
      ShardIds).

-spec ensure_shard(shard(), emqx_ds_storage_layer:options()) ->
    ok | {error, _Reason}.
ensure_shard(Sharzd, Options) ->
    case emqx_ds_storage_layer_sup:start_shard(Shard, Options) of
        {ok, _Pid} ->
            ok;
        {error, {already_started, _Pid}} ->
            ok;
        {error, Reason} ->
            {error, Reason}
    end.

%%--------------------------------------------------------------------------------
%% Message
%%--------------------------------------------------------------------------------

-spec message_store([emqx_types:message()], message_store_opts()) ->
    {ok, [message_id()]} | {error, _}.
message_store(Msg, Opts) ->
    message_store(Msg, Opts).

-spec message_store([emqx_types:message()]) -> {ok, [message_id()]} | {error, _}.
message_store(Msg) ->
    message_store(Msg, #{}).

-spec message_stats() -> message_stats().
message_stats() ->
    #{}.

%%--------------------------------------------------------------------------------
%% Iterator (pull API)
%%--------------------------------------------------------------------------------

-spec open_iterator(stream()) -> {ok, iterator()}.
open_iterator(#stream{shard = {_Keyspace, _ShardId}, stream = _StorageSpecificStream}) ->
    error(todo).

-spec next(iterator(), non_neg_integer()) ->
          {ok, iterator(), [emqx_types:message()]}
        | end_of_stream.
next(_Iterator, _BatchSize) ->
    error(todo).

%%================================================================================
%% Internal functions
%%================================================================================
